/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');
require('crypto');
require('fs');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const VOICENOTES_API_URL = 'https://api.voicenotes.com/api';
class VoiceNotesApi {
    constructor(options) {
        if (options.token) {
            this.token = options.token;
        }
    }
    setToken(token) {
        this.token = token;
    }
    login(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.username && options.password) {
                const loginUrl = `${VOICENOTES_API_URL}/auth/login`;
                console.log(`loginUrl: ${loginUrl}`);
                const response = yield obsidian.requestUrl({
                    url: loginUrl,
                    method: 'POST',
                    contentType: 'application/json',
                    body: JSON.stringify({
                        email: options.username,
                        password: options.password,
                    }),
                });
                if (response.status === 200) {
                    this.token = response.json.authorisation.token;
                    return this.token;
                }
                return null;
            }
            return null;
        });
    }
    getSignedUrl(recordingId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.token) {
                const data = yield obsidian.requestUrl({
                    url: `${VOICENOTES_API_URL}/recordings/${recordingId}/signed-url`,
                    headers: {
                        Authorization: `Bearer ${this.token}`,
                    },
                });
                return data.json;
            }
            return null;
        });
    }
    downloadFile(fs, url, outputLocationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield obsidian.requestUrl({
                url,
            });
            const buffer = Buffer.from(response.arrayBuffer);
            yield fs.writeBinary(outputLocationPath, buffer);
        });
    }
    deleteRecording(recordingId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.token) {
                const data = yield obsidian.requestUrl({
                    url: `${VOICENOTES_API_URL}/recordings/${recordingId}`,
                    headers: {
                        Authorization: `Bearer ${this.token}`,
                    },
                    method: 'DELETE',
                });
                return data.status === 200;
            }
            return false;
        });
    }
    getRecordingsFromLink(link) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.token) {
                const data = yield obsidian.requestUrl({
                    url: link,
                    headers: {
                        Authorization: `Bearer ${this.token}`,
                    },
                });
                return data.json;
            }
            return null;
        });
    }
    getRecordings() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.token) {
                try {
                    const data = yield obsidian.requestUrl({
                        url: `${VOICENOTES_API_URL}/recordings`,
                        headers: {
                            Authorization: `Bearer ${this.token}`,
                        },
                    });
                    return data.json;
                }
                catch (error) {
                    if (error.status === 401) {
                        this.token = undefined;
                        throw error; // rethrow so we can catch in caller
                    }
                }
            }
            return null;
        });
    }
    getUserInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.token) {
                try {
                    const data = yield obsidian.requestUrl({
                        url: `${VOICENOTES_API_URL}/auth/me`,
                        headers: {
                            Authorization: `Bearer ${this.token}`,
                        },
                    });
                    return data.json;
                }
                catch (error) {
                    console.error(error);
                }
            }
            return null;
        });
    }
}

function getFilenameFromUrl(url) {
    try {
        const parsedUrl = new URL(url);
        const pathname = parsedUrl.pathname;
        const filename = pathname.split('/').pop();
        return filename || '';
    }
    catch (error) {
        console.error('Invalid URL:', error);
        return '';
    }
}
function isToday(date) {
    return obsidian.moment(date).isSame(obsidian.moment(), 'day');
}
function formatDuration(durationMs) {
    const minutes = Math.floor(durationMs / 60000);
    const seconds = Math.floor((durationMs % 60000) / 1000);
    if (minutes > 0) {
        return `${minutes}m${seconds.toString().padStart(2, '0')}s`;
    }
    else {
        return `${seconds}s`;
    }
}
function formatDate(date, dateFormat) {
    try {
        return obsidian.moment(date).format(dateFormat);
    }
    catch (error) {
        console.error('Error formatting date:', error);
        return date;
    }
}
function formatTags(recording) {
    if (recording.tags && recording.tags.length > 0) {
        return `tags: ${recording.tags.map((tag) => tag.name.replace(/\s+/g, '-')).join(',')}`;
    }
    return '';
}
function autoResizeTextArea(textarea) {
    requestAnimationFrame(() => {
        textarea.style.height = 'auto';
        textarea.style.height = `${textarea.scrollHeight}px`;
    });
}
function convertHtmlToMarkdown(text) {
    const htmlEntities = {
        '&lt;': '<',
        '&gt;': '>',
        '&amp;': '&',
        '&quot;': '"',
        '&#39;': "'",
        '&nbsp;': ' ',
    };
    // Convert HTML entities
    let markdown = text.replace(/&[a-zA-Z0-9#]+;/g, (entity) => htmlEntities[entity] || entity);
    // Convert <br/> tags to newlines
    markdown = markdown.replace(/<br\s*\/?>/gi, '\n');
    // Remove other HTML tags
    markdown = markdown.replace(/<\/?[^>]+(>|$)/g, '');
    return markdown.trim();
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var build = {};

function isHighSurrogate$1(codePoint) {
  return codePoint >= 0xd800 && codePoint <= 0xdbff;
}

function isLowSurrogate$1(codePoint) {
  return codePoint >= 0xdc00 && codePoint <= 0xdfff;
}

// Truncate string by size in bytes
var truncate$1 = function truncate(getLength, string, byteLength) {
  if (typeof string !== "string") {
    throw new Error("Input must be string");
  }

  var charLength = string.length;
  var curByteLength = 0;
  var codePoint;
  var segment;

  for (var i = 0; i < charLength; i += 1) {
    codePoint = string.charCodeAt(i);
    segment = string[i];

    if (isHighSurrogate$1(codePoint) && isLowSurrogate$1(string.charCodeAt(i + 1))) {
      i += 1;
      segment += string[i];
    }

    curByteLength += getLength(segment);

    if (curByteLength === byteLength) {
      return string.slice(0, i + 1);
    }
    else if (curByteLength > byteLength) {
      return string.slice(0, i - segment.length + 1);
    }
  }

  return string;
};

function isHighSurrogate(codePoint) {
  return codePoint >= 0xd800 && codePoint <= 0xdbff;
}

function isLowSurrogate(codePoint) {
  return codePoint >= 0xdc00 && codePoint <= 0xdfff;
}

// Truncate string by size in bytes
var browser$1 = function getByteLength(string) {
  if (typeof string !== "string") {
    throw new Error("Input must be string");
  }

  var charLength = string.length;
  var byteLength = 0;
  var codePoint = null;
  var prevCodePoint = null;
  for (var i = 0; i < charLength; i++) {
    codePoint = string.charCodeAt(i);
    // handle 4-byte non-BMP chars
    // low surrogate
    if (isLowSurrogate(codePoint)) {
      // when parsing previous hi-surrogate, 3 is added to byteLength
      if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
        byteLength += 1;
      }
      else {
        byteLength += 3;
      }
    }
    else if (codePoint <= 0x7f ) {
      byteLength += 1;
    }
    else if (codePoint >= 0x80 && codePoint <= 0x7ff) {
      byteLength += 2;
    }
    else if (codePoint >= 0x800 && codePoint <= 0xffff) {
      byteLength += 3;
    }
    prevCodePoint = codePoint;
  }

  return byteLength;
};

var truncate = truncate$1;
var getLength = browser$1;
var browser = truncate.bind(null, getLength);

var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(build, "__esModule", { value: true });
const truncate_utf8_bytes_1 = __importDefault(browser);
/**
 * Replaces characters in strings that are illegal/unsafe for filenames.
 * Unsafe characters are either removed or replaced by a substitute set
 * in the optional `options` object.
 *
 * Illegal Characters on Various Operating Systems
 * / ? < > \ : * | "
 * https://kb.acronis.com/content/39790
 *
 * Unicode Control codes
 * C0 0x00-0x1f & C1 (0x80-0x9f)
 * http://en.wikipedia.org/wiki/C0_and_C1_control_codes
 *
 * Reserved filenames on Unix-based systems (".", "..")
 * Reserved filenames in Windows ("CON", "PRN", "AUX", "NUL", "COM1",
 * "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
 * "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", and
 * "LPT9") case-insesitively and with or without filename extensions.
 *
 * Capped at 255 characters in length.
 * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs
 *
 * @param  {String} input   Original filename
 * @param  {Object} options {replacement: String}
 * @return {String}         Sanitized filename
 */
const illegalRe = /[\/\?<>\\:\*\|":]/g;
/* tslint:disable-next-line:no-control-regex */
const controlRe = /[\x00-\x1f\x80-\x9f]/g;
const reservedRe = /^\.+$/;
const windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
const windowsTrailingRe = /[\. ]+$/;
function replace(input, replacement) {
    const sanitized = input
        .replace(illegalRe, replacement)
        .replace(controlRe, replacement)
        .replace(reservedRe, replacement)
        .replace(windowsReservedRe, replacement)
        .replace(windowsTrailingRe, replacement);
    return truncate_utf8_bytes_1.default(sanitized, 255);
}
function sanitize(input, options) {
    const replacement = (options && options.replacement) || "";
    const output = replace(input, replacement);
    if (replacement === "") {
        return output;
    }
    return replace(output, "");
}
var sanitize_1 = build.sanitize = sanitize;

class VoiceNotesSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
        this.vnApi = new VoiceNotesApi({});
    }
    display() {
        return __awaiter(this, void 0, void 0, function* () {
            const { containerEl } = this;
            containerEl.empty();
            if (!this.plugin.settings.token) {
                new obsidian.Setting(containerEl).setName('Username').addText((text) => text
                    .setPlaceholder('Email address')
                    .setValue(this.plugin.settings.username)
                    .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.username = value;
                    yield this.plugin.saveSettings();
                })));
                new obsidian.Setting(containerEl).setName('Password').addText((text) => {
                    text
                        .setPlaceholder('Password')
                        .setValue(this.plugin.settings.password)
                        .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                        this.password = value;
                        yield this.plugin.saveSettings();
                    }));
                    text.inputEl.type = 'password';
                    return text;
                });
                new obsidian.Setting(containerEl).addButton((button) => button.setButtonText('Login').onClick(() => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.token = yield this.vnApi.login({
                        username: this.plugin.settings.username,
                        password: this.password,
                    });
                    this.plugin.settings.password = null;
                    if (this.plugin.settings.token) {
                        new obsidian.Notice('Login to voicenotes.com was successful');
                        yield this.plugin.saveSettings();
                        this.plugin.setupAutoSync();
                        yield this.display();
                    }
                    else {
                        new obsidian.Notice('Login to voicenotes.com was unsuccessful');
                    }
                })));
                new obsidian.Setting(containerEl).setName('Auth Token').addText((text) => text
                    .setPlaceholder('12345|abcdefghijklmnopqrstuvwxyz')
                    .setValue(this.plugin.settings.token)
                    .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.token = value;
                    yield this.plugin.saveSettings();
                })));
                new obsidian.Setting(containerEl).addButton((button) => button.setButtonText('Login with token').onClick(() => __awaiter(this, void 0, void 0, function* () {
                    this.vnApi.setToken(this.plugin.settings.token);
                    const response = yield this.vnApi.getUserInfo();
                    this.plugin.settings.password = null;
                    if (response) {
                        new obsidian.Notice('Login to voicenotes.com was successful');
                        yield this.plugin.saveSettings();
                        this.plugin.setupAutoSync();
                        yield this.display();
                    }
                    else {
                        new obsidian.Notice('Login to voicenotes.com was unsuccessful');
                    }
                })));
            }
            if (this.plugin.settings.token) {
                this.vnApi.setToken(this.plugin.settings.token);
                const userInfo = yield this.vnApi.getUserInfo();
                new obsidian.Setting(containerEl).setName('Name').addText((text) => text.setPlaceholder(userInfo.name).setDisabled(true));
                new obsidian.Setting(containerEl)
                    .setName('Email')
                    .addText((text) => text.setPlaceholder(userInfo.email).setDisabled(true));
                new obsidian.Setting(containerEl).addButton((button) => button.setButtonText('Logout').onClick(() => __awaiter(this, void 0, void 0, function* () {
                    new obsidian.Notice('Logged out of voicenotes.com');
                    this.plugin.settings.token = null;
                    this.plugin.settings.password = null;
                    this.password = null;
                    yield this.plugin.saveSettings();
                    yield this.display();
                })));
                new obsidian.Setting(containerEl)
                    .setName('Force Sync')
                    .setDesc("Manual synchronization -- Prefer using the quick sync option unless you're having issues with syncing. Full synchronization will sync all notes, not just the last ten but can be much slower.")
                    .addButton((button) => button.setButtonText('Manual sync (quick)').onClick(() => __awaiter(this, void 0, void 0, function* () {
                    new obsidian.Notice('Performing manual synchronization of the last ten notes.');
                    yield this.plugin.sync();
                    new obsidian.Notice('Manual quick synchronization has completed.');
                })))
                    .addButton((button) => button.setButtonText('Manual sync (full)').onClick(() => __awaiter(this, void 0, void 0, function* () {
                    new obsidian.Notice('Performing manual synchronization of all notes.');
                    this.plugin.syncedRecordingIds = [];
                    yield this.plugin.sync(true);
                    new obsidian.Notice('Manual full synchronization has completed.');
                })));
            }
            new obsidian.Setting(containerEl)
                .setName('Automatic sync every')
                .setDesc('Number of minutes between syncing with VoiceNotes.com servers (uncheck to sync manually)')
                .addText((text) => {
                text
                    .setDisabled(!this.plugin.settings.automaticSync)
                    .setPlaceholder('30')
                    .setValue(`${this.plugin.settings.syncTimeout}`)
                    .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    const numericValue = Number(value);
                    const inputElement = text.inputEl;
                    if (isNaN(numericValue) || numericValue < 1) {
                        inputElement.style.backgroundColor = 'red';
                        new obsidian.Notice('Please enter a number greater than or equal to 1');
                    }
                    else {
                        inputElement.style.backgroundColor = '';
                        this.plugin.settings.syncTimeout = numericValue;
                        yield this.plugin.saveSettings();
                    }
                }));
                text.inputEl.type = 'number';
                return text;
            })
                .addToggle((toggle) => toggle.setValue(this.plugin.settings.automaticSync).onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.automaticSync = value;
                // If we've turned on automatic sync again, let's re-sync right away
                if (value) {
                    yield this.plugin.sync(false);
                }
                yield this.plugin.saveSettings();
                yield this.display();
            })));
            new obsidian.Setting(containerEl)
                .setName('Sync directory')
                .setDesc('Directory to sync voice notes')
                .addText((text) => text
                .setPlaceholder('voicenotes')
                .setValue(`${this.plugin.settings.syncDirectory}`)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.syncDirectory = value;
                yield this.plugin.saveSettings();
            })));
            new obsidian.Setting(containerEl)
                .setName('Add a tag to todos')
                .setDesc('When syncing a note add an optional tag to the todo')
                .addText((text) => text
                .setPlaceholder('TODO')
                .setValue(this.plugin.settings.todoTag)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.todoTag = value;
                yield this.plugin.saveSettings();
            })));
            new obsidian.Setting(containerEl)
                .setName('Download audio')
                .setDesc('Store and download the audio associated with the transcript')
                .addToggle((toggle) => toggle.setValue(this.plugin.settings.downloadAudio).onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.downloadAudio = Boolean(value);
                yield this.plugin.saveSettings();
            })));
            new obsidian.Setting(containerEl)
                .setName('Date Format')
                .setDesc('Format of the date used in the templates below (moment.js format)')
                .addText((text) => text
                .setPlaceholder('YYYY-MM-DD')
                .setValue(this.plugin.settings.dateFormat)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.dateFormat = value;
                yield this.plugin.saveSettings();
            })));
            new obsidian.Setting(containerEl)
                .setName('Filename Date Format')
                .setDesc('Format of the date used to replace {{date}} if in Filename Template below (moment.js format)')
                .addText((text) => text
                .setPlaceholder('YYYY-MM-DD')
                .setValue(this.plugin.settings.filenameDateFormat)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.filenameDateFormat = value;
                yield this.plugin.saveSettings();
            })));
            new obsidian.Setting(containerEl)
                .setName('Filename Template')
                .setDesc('Template for the filename of synced notes. Available variables: {{date}}, {{title}}')
                .addText((text) => text
                .setPlaceholder('{{date}} {{title}}')
                .setValue(this.plugin.settings.filenameTemplate)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.filenameTemplate = value;
                yield this.plugin.saveSettings();
            })));
            new obsidian.Setting(containerEl)
                .setName('Custom Note Template')
                .setDesc('Custom template for synced notes. Available variables: {{recording_id}}, {{title}}, {{date}}, {{transcript}}, {{audio_link}}, {{summary}}, {{tidy}}, {{points}}, {{todo}}, {{email}}, {{tweet}}, {{blog}}, {{custom}}, {{parent_note}} and {{related_notes}} (uncheck to add a custom frontmatter)')
                .addTextArea((text) => {
                text
                    .setPlaceholder(this.plugin.settings.noteTemplate)
                    .setValue(this.plugin.settings.noteTemplate)
                    .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.noteTemplate = value;
                    yield this.plugin.saveSettings();
                }));
                // Add autoresize to the textarea
                text.inputEl.classList.add('autoresize');
                autoResizeTextArea(text.inputEl);
                text.inputEl.addEventListener('input', () => autoResizeTextArea(text.inputEl));
                containerEl.appendChild(text.inputEl);
            })
                .addToggle((toggle) => {
                toggle.setValue(this.plugin.settings.useDefaultFrontmatter).onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.useDefaultFrontmatter = value;
                    yield this.plugin.saveSettings();
                }));
            });
            new obsidian.Setting(containerEl)
                .setName('Exclude Tags')
                .setDesc('Comma-separated list of tags to exclude from syncing')
                .addText((text) => text
                .setPlaceholder('archive, trash')
                .setValue(this.plugin.settings.excludeTags.join(', '))
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.excludeTags = value.split(',').map((folder) => folder.trim());
                yield this.plugin.saveSettings();
            })));
        });
    }
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var jinja$1 = {exports: {}};

/*!
 * Jinja Templating for JavaScript v0.1.8
 * https://github.com/sstur/jinja-js
 *
 * This is a slimmed-down Jinja2 implementation [http://jinja.pocoo.org/]
 *
 * In the interest of simplicity, it deviates from Jinja2 as follows:
 * - Line statements, cycle, super, macros and block nesting are not implemented
 * - auto escapes html by default (the filter is "html" not "e")
 * - Only "html" and "safe" filters are built in
 * - Filters are not valid in expressions; `foo|length > 1` is not valid
 * - Expression Tests (`if num is odd`) not implemented (`is` translates to `==` and `isnot` to `!=`)
 *
 * Notes:
 * - if property is not found, but method '_get' exists, it will be called with the property name (and cached)
 * - `{% for n in obj %}` iterates the object's keys; get the value with `{% for n in obj %}{{ obj[n] }}{% endfor %}`
 * - subscript notation `a[0]` takes literals or simple variables but not `a[item.key]`
 * - `.2` is not a valid number literal; use `0.2`
 *
 */

(function (module, exports) {
	(function(definition) {
	  {
	    // CommonJS/Node
	    return definition(commonjsRequire, exports, module);
	  }
	})(function(require, jinja) {
	  var STRINGS = /'(\\.|[^'])*'|"(\\.|[^"'"])*"/g;
	  var IDENTS_AND_NUMS = /([$_a-z][$\w]*)|([+-]?\d+(\.\d+)?)/g;
	  var NUMBER = /^[+-]?\d+(\.\d+)?$/;
	  //non-primitive literals (array and object literals)
	  var NON_PRIMITIVES = /\[[@#~](,[@#~])*\]|\[\]|\{([@i]:[@#~])(,[@i]:[@#~])*\}|\{\}/g;
	  //bare identifiers such as variables and in object literals: {foo: 'value'}
	  var IDENTIFIERS = /[$_a-z][$\w]*/ig;
	  var VARIABLES = /i(\.i|\[[@#i]\])*/g;
	  var ACCESSOR = /(\.i|\[[@#i]\])/g;
	  var OPERATORS = /(===?|!==?|>=?|<=?|&&|\|\||[+\-\*\/%])/g;
	  //extended (english) operators
	  var EOPS = /(^|[^$\w])(and|or|not|is|isnot)([^$\w]|$)/g;
	  var LEADING_SPACE = /^\s+/;
	  var TRAILING_SPACE = /\s+$/;

	  var START_TOKEN = /\{\{\{|\{\{|\{%|\{#/;
	  var TAGS = {
	    '{{{': /^('(\\.|[^'])*'|"(\\.|[^"'"])*"|.)+?\}\}\}/,
	    '{{': /^('(\\.|[^'])*'|"(\\.|[^"'"])*"|.)+?\}\}/,
	    '{%': /^('(\\.|[^'])*'|"(\\.|[^"'"])*"|.)+?%\}/,
	    '{#': /^('(\\.|[^'])*'|"(\\.|[^"'"])*"|.)+?#\}/
	  };

	  var delimeters = {
	    '{%': 'directive',
	    '{{': 'output',
	    '{#': 'comment'
	  };

	  var operators = {
	    and: '&&',
	    or: '||',
	    not: '!',
	    is: '==',
	    isnot: '!='
	  };

	  var constants = {
	    'true': true,
	    'false': false,
	    'null': null
	  };

	  function Parser() {
	    this.nest = [];
	    this.compiled = [];
	    this.childBlocks = 0;
	    this.parentBlocks = 0;
	    this.isSilent = false;
	  }

	  Parser.prototype.push = function(line) {
	    if (!this.isSilent) {
	      this.compiled.push(line);
	    }
	  };

	  Parser.prototype.parse = function(src) {
	    this.tokenize(src);
	    return this.compiled;
	  };

	  Parser.prototype.tokenize = function(src) {
	    var lastEnd = 0, parser = this, trimLeading = false;
	    matchAll(src, START_TOKEN, function(open, index, src) {
	      //here we match the rest of the src against a regex for this tag
	      var match = src.slice(index + open.length).match(TAGS[open]);
	      match = (match ? match[0] : '');
	      //here we sub out strings so we don't get false matches
	      var simplified = match.replace(STRINGS, '@');
	      //if we don't have a close tag or there is a nested open tag
	      if (!match || ~simplified.indexOf(open)) {
	        return index + 1;
	      }
	      var inner = match.slice(0, 0 - open.length);
	      //check for white-space collapse syntax
	      if (inner.charAt(0) == '-') var wsCollapseLeft = true;
	      if (inner.slice(-1) == '-') var wsCollapseRight = true;
	      inner = inner.replace(/^-|-$/g, '').trim();
	      //if we're in raw mode and we are not looking at an "endraw" tag, move along
	      if (parser.rawMode && (open + inner) != '{%endraw') {
	        return index + 1;
	      }
	      var text = src.slice(lastEnd, index);
	      lastEnd = index + open.length + match.length;
	      if (trimLeading) text = trimLeft(text);
	      if (wsCollapseLeft) text = trimRight(text);
	      if (wsCollapseRight) trimLeading = true;
	      if (open == '{{{') {
	        //liquid-style: make {{{x}}} => {{x|safe}}
	        open = '{{';
	        inner += '|safe';
	      }
	      parser.textHandler(text);
	      parser.tokenHandler(open, inner);
	    });
	    var text = src.slice(lastEnd);
	    if (trimLeading) text = trimLeft(text);
	    this.textHandler(text);
	  };

	  Parser.prototype.textHandler = function(text) {
	    this.push('write(' + JSON.stringify(text) + ');');
	  };

	  Parser.prototype.tokenHandler = function(open, inner) {
	    var type = delimeters[open];
	    if (type == 'directive') {
	      this.compileTag(inner);
	    } else
	    if (type == 'output') {
	      var extracted = this.extractEnt(inner, STRINGS, '@');
	      //replace || operators with ~
	      extracted.src = extracted.src.replace(/\|\|/g, '~').split('|');
	      //put back || operators
	      extracted.src = extracted.src.map(function(part) {
	        return part.split('~').join('||');
	      });
	      var parts = this.injectEnt(extracted, '@');
	      if (parts.length > 1) {
	        var filters = parts.slice(1).map(this.parseFilter.bind(this));
	        this.push('filter(' + this.parseExpr(parts[0]) + ',' + filters.join(',') + ');');
	      } else {
	        this.push('filter(' + this.parseExpr(parts[0]) + ');');
	      }
	    }
	  };

	  Parser.prototype.compileTag = function(str) {
	    var directive = str.split(' ')[0];
	    var handler = tagHandlers[directive];
	    if (!handler) {
	      throw new Error('Invalid tag: ' + str);
	    }
	    handler.call(this, str.slice(directive.length).trim());
	  };

	  Parser.prototype.parseFilter = function(src) {
	    src = src.trim();
	    var match = src.match(/[:(]/);
	    var i = match ? match.index : -1;
	    if (i < 0) return JSON.stringify([src]);
	    var name = src.slice(0, i);
	    var args = src.charAt(i) == ':' ? src.slice(i + 1) : src.slice(i + 1, -1);
	    args = this.parseExpr(args, {terms: true});
	    return '[' + JSON.stringify(name) + ',' + args + ']';
	  };

	  Parser.prototype.extractEnt = function(src, regex, placeholder) {
	    var subs = [], isFunc = typeof placeholder == 'function';
	    src = src.replace(regex, function(str) {
	      var replacement = isFunc ? placeholder(str) : placeholder;
	      if (replacement) {
	        subs.push(str);
	        return replacement;
	      }
	      return str;
	    });
	    return {src: src, subs: subs};
	  };

	  Parser.prototype.injectEnt = function(extracted, placeholder) {
	    var src = extracted.src, subs = extracted.subs, isArr = Array.isArray(src);
	    var arr = (isArr) ? src : [src];
	    var re = new RegExp('[' + placeholder + ']', 'g'), i = 0;
	    arr.forEach(function(src, index) {
	      arr[index] = src.replace(re, function() {
	        return subs[i++];
	      });
	    });
	    return isArr ? arr : arr[0];
	  };

	  //replace complex literals without mistaking subscript notation with array literals
	  Parser.prototype.replaceComplex = function(s) {
	    var parsed = this.extractEnt(s, /i(\.i|\[[@#i]\])+/g, 'v');
	    parsed.src = parsed.src.replace(NON_PRIMITIVES, '~');
	    return this.injectEnt(parsed, 'v');
	  };

	  //parse expression containing literals (including objects/arrays) and variables (including dot and subscript notation)
	  //valid expressions: `a + 1 > b.c or c == null`, `a and b[1] != c`, `(a < b) or (c < d and e)`, 'a || [1]`
	  Parser.prototype.parseExpr = function(src, opts) {
	    opts = opts || {};
	    //extract string literals -> @
	    var parsed1 = this.extractEnt(src, STRINGS, '@');
	    //note: this will catch {not: 1} and a.is; could we replace temporarily and then check adjacent chars?
	    parsed1.src = parsed1.src.replace(EOPS, function(s, before, op, after) {
	      return (op in operators) ? before + operators[op] + after : s;
	    });
	    //sub out non-string literals (numbers/true/false/null) -> #
	    // the distinction is necessary because @ can be object identifiers, # cannot
	    var parsed2 = this.extractEnt(parsed1.src, IDENTS_AND_NUMS, function(s) {
	      return (s in constants || NUMBER.test(s)) ? '#' : null;
	    });
	    //sub out object/variable identifiers -> i
	    var parsed3 = this.extractEnt(parsed2.src, IDENTIFIERS, 'i');
	    //remove white-space
	    parsed3.src = parsed3.src.replace(/\s+/g, '');

	    //the rest of this is simply to boil the expression down and check validity
	    var simplified = parsed3.src;
	    //sub out complex literals (objects/arrays) -> ~
	    // the distinction is necessary because @ and # can be subscripts but ~ cannot
	    while (simplified != (simplified = this.replaceComplex(simplified)));
	    //now @ represents strings, # represents other primitives and ~ represents non-primitives
	    //replace complex variables (those with dot/subscript accessors) -> v
	    while (simplified != (simplified = simplified.replace(/i(\.i|\[[@#i]\])+/, 'v')));
	    //empty subscript or complex variables in subscript, are not permitted
	    simplified = simplified.replace(/[iv]\[v?\]/g, 'x');
	    //sub in "i" for @ and # and ~ and v (now "i" represents all literals, variables and identifiers)
	    simplified = simplified.replace(/[@#~v]/g, 'i');
	    //sub out operators
	    simplified = simplified.replace(OPERATORS, '%');
	    //allow 'not' unary operator
	    simplified = simplified.replace(/!+[i]/g, 'i');
	    var terms = opts.terms ? simplified.split(',') : [simplified];
	    terms.forEach(function(term) {
	      //simplify logical grouping
	      while (term != (term = term.replace(/\(i(%i)*\)/g, 'i')));
	      if (!term.match(/^i(%i)*$/)) {
	        throw new Error('Invalid expression: ' + src);
	      }
	    });
	    parsed3.src = parsed3.src.replace(VARIABLES, this.parseVar.bind(this));
	    parsed2.src = this.injectEnt(parsed3, 'i');
	    parsed1.src = this.injectEnt(parsed2, '#');
	    return this.injectEnt(parsed1, '@');
	  };

	  Parser.prototype.parseVar = function(src) {
	    var args = Array.prototype.slice.call(arguments);
	    var str = args.pop(), index = args.pop();
	    //quote bare object identifiers (might be a reserved word like {while: 1})
	    if (src == 'i' && str.charAt(index + 1) == ':') {
	      return '"i"';
	    }
	    var parts = ['"i"'];
	    src.replace(ACCESSOR, function(part) {
	      if (part == '.i') {
	        parts.push('"i"');
	      } else
	      if (part == '[i]') {
	        parts.push('get("i")');
	      } else {
	        parts.push(part.slice(1, -1));
	      }
	    });
	    return 'get(' + parts.join(',') + ')';
	  };

	  //escapes a name to be used as a javascript identifier
	  Parser.prototype.escName = function(str) {
	    return str.replace(/\W/g, function(s) {
	      return '$' + s.charCodeAt(0).toString(16);
	    });
	  };

	  Parser.prototype.parseQuoted = function(str) {
	    if (str.charAt(0) == "'") {
	      str = str.slice(1, -1).replace(/\\.|"/, function(s) {
	        if (s == "\\'") return "'";
	        return s.charAt(0) == '\\' ? s : ('\\' + s);
	      });
	      str = '"' + str + '"';
	    }
	    //todo: try/catch or deal with invalid characters (linebreaks, control characters)
	    return JSON.parse(str);
	  };


	  //the context 'this' inside tagHandlers is the parser instance
	  var tagHandlers = {
	    'if': function(expr) {
	      this.push('if (' + this.parseExpr(expr) + ') {');
	      this.nest.unshift('if');
	    },
	    'else': function() {
	      if (this.nest[0] == 'for') {
	        this.push('}, function() {');
	      } else {
	        this.push('} else {');
	      }
	    },
	    'elseif': function(expr) {
	      this.push('} else if (' + this.parseExpr(expr) + ') {');
	    },
	    'endif': function() {
	      this.nest.shift();
	      this.push('}');
	    },
	    'for': function(str) {
	      var i = str.indexOf(' in ');
	      var name = str.slice(0, i).trim();
	      var expr = str.slice(i + 4).trim();
	      this.push('each(' + this.parseExpr(expr) + ',' + JSON.stringify(name) + ',function() {');
	      this.nest.unshift('for');
	    },
	    'endfor': function() {
	      this.nest.shift();
	      this.push('});');
	    },
	    'raw': function() {
	      this.rawMode = true;
	    },
	    'endraw': function() {
	      this.rawMode = false;
	    },
	    'set': function(stmt) {
	      var i = stmt.indexOf('=');
	      var name = stmt.slice(0, i).trim();
	      var expr = stmt.slice(i + 1).trim();
	      this.push('set(' + JSON.stringify(name) + ',' + this.parseExpr(expr) + ');');
	    },
	    'block': function(name) {
	      if (this.isParent) {
	        ++this.parentBlocks;
	        var blockName = 'block_' + (this.escName(name) || this.parentBlocks);
	        this.push('block(typeof ' + blockName + ' == "function" ? ' + blockName + ' : function() {');
	      } else
	      if (this.hasParent) {
	        this.isSilent = false;
	        ++this.childBlocks;
	        blockName = 'block_' + (this.escName(name) || this.childBlocks);
	        this.push('function ' + blockName + '() {');
	      }
	      this.nest.unshift('block');
	    },
	    'endblock': function() {
	      this.nest.shift();
	      if (this.isParent) {
	        this.push('});');
	      } else
	      if (this.hasParent) {
	        this.push('}');
	        this.isSilent = true;
	      }
	    },
	    'extends': function(name) {
	      name = this.parseQuoted(name);
	      var parentSrc = this.readTemplateFile(name);
	      this.isParent = true;
	      this.tokenize(parentSrc);
	      this.isParent = false;
	      this.hasParent = true;
	      //silence output until we enter a child block
	      this.isSilent = true;
	    },
	    'include': function(name) {
	      name = this.parseQuoted(name);
	      var incSrc = this.readTemplateFile(name);
	      this.isInclude = true;
	      this.tokenize(incSrc);
	      this.isInclude = false;
	    }
	  };

	  //liquid style
	  tagHandlers.assign = tagHandlers.set;
	  //python/django style
	  tagHandlers.elif = tagHandlers.elseif;

	  var getRuntime = function runtime(data, opts) {
	    var defaults = {autoEscape: 'html'};
	    var _toString = Object.prototype.toString;
	    var _hasOwnProperty = Object.prototype.hasOwnProperty;
	    var toString = function(val) {
	      if (val == null) return '';
	      return (typeof val.toString == 'function') ? val.toString() : _toString.call(val);
	    };
	    var extend = function(dest, src) {
	      Object.keys(src).forEach(function(key) {
	        dest[key] = src[key];
	      });
	      return dest;
	    };
	    //get a value, lexically, starting in current context; a.b -> get("a","b")
	    var get = function() {
	      var val, n = arguments[0], c = stack.length;
	      while (c--) {
	        val = stack[c][n];
	        if (typeof val != 'undefined') break;
	      }
	      for (var i = 1, len = arguments.length; i < len; i++) {
	        if (val == null) continue;
	        n = arguments[i];
	        val = (_hasOwnProperty.call(val, n)) ? val[n] : (typeof val._get == 'function' ? (val[n] = val._get(n)) : null);
	      }
	      return (val == null) ? null : val;
	    };
	    var set = function(n, val) {
	      stack[stack.length - 1][n] = val;
	    };
	    var push = function(ctx) {
	      stack.push(ctx || {});
	    };
	    var pop = function() {
	      stack.pop();
	    };
	    var write = function(str) {
	      output.push(str);
	    };
	    var filter = function(val) {
	      for (var i = 1, len = arguments.length; i < len; i++) {
	        var arr = arguments[i], name = arr[0], filter = filters[name];
	        if (filter) {
	          arr[0] = val;
	          //now arr looks like [val, arg1, arg2]
	          val = filter.apply(data, arr);
	        } else {
	          throw new Error('Invalid filter: ' + name);
	        }
	      }
	      if (opts.autoEscape && name != opts.autoEscape && name != 'safe') {
	        //auto escape if not explicitly safe or already escaped
	        val = filters[opts.autoEscape].call(data, val);
	      }
	      output.push(val);
	    };
	    var each = function(obj, loopvar, fn1, fn2) {
	      if (obj == null) return;
	      var arr = Array.isArray(obj) ? obj : Object.keys(obj), len = arr.length;
	      var ctx = {loop: {length: len, first: arr[0], last: arr[len - 1]}};
	      push(ctx);
	      for (var i = 0; i < len; i++) {
	        extend(ctx.loop, {index: i + 1, index0: i});
	        fn1(ctx[loopvar] = arr[i]);
	      }
	      if (len == 0 && fn2) fn2();
	      pop();
	    };
	    var block = function(fn) {
	      push();
	      fn();
	      pop();
	    };
	    var render = function() {
	      return output.join('');
	    };
	    data = data || {};
	    opts = extend(defaults, opts || {});
	    var filters = extend({
	      html: function(val) {
	        return toString(val)
	          .split('&').join('&amp;')
	          .split('<').join('&lt;')
	          .split('>').join('&gt;')
	          .split('"').join('&quot;');
	      },
	      safe: function(val) {
	        return val;
	      }
	    }, opts.filters || {});
	    var stack = [Object.create(data || {})], output = [];
	    return {get: get, set: set, push: push, pop: pop, write: write, filter: filter, each: each, block: block, render: render};
	  };

	  var runtime;

	  jinja.compile = function(markup, opts) {
	    opts = opts || {};
	    var parser = new Parser();
	    parser.readTemplateFile = this.readTemplateFile;
	    var code = [];
	    code.push('function render($) {');
	    code.push('var get = $.get, set = $.set, push = $.push, pop = $.pop, write = $.write, filter = $.filter, each = $.each, block = $.block;');
	    code.push.apply(code, parser.parse(markup));
	    code.push('return $.render();');
	    code.push('}');
	    code = code.join('\n');
	    if (opts.runtime === false) {
	      var fn = new Function('data', 'options', 'return (' + code + ')(runtime(data, options))');
	    } else {
	      runtime = runtime || (runtime = getRuntime.toString());
	      fn = new Function('data', 'options', 'return (' + code + ')((' + runtime + ')(data, options))');
	    }
	    return {render: fn};
	  };

	  jinja.render = function(markup, data, opts) {
	    var tmpl = jinja.compile(markup);
	    return tmpl.render(data, opts);
	  };

	  jinja.templateFiles = [];

	  jinja.readTemplateFile = function(name) {
	    var templateFiles = this.templateFiles || [];
	    var templateFile = templateFiles[name];
	    if (templateFile == null) {
	      throw new Error('Template file not found: ' + name);
	    }
	    return templateFile;
	  };


	  /*!
	   * Helpers
	   */

	  function trimLeft(str) {
	    return str.replace(LEADING_SPACE, '');
	  }

	  function trimRight(str) {
	    return str.replace(TRAILING_SPACE, '');
	  }

	  function matchAll(str, reg, fn) {
	    //copy as global
	    reg = new RegExp(reg.source, 'g' + (reg.ignoreCase ? 'i' : '') + (reg.multiline ? 'm' : ''));
	    var match;
	    while ((match = reg.exec(str))) {
	      var result = fn(match[0], match.index, str);
	      if (typeof result == 'number') {
	        reg.lastIndex = result;
	      }
	    }
	  }

	}); 
} (jinja$1, jinja$1.exports));

var jinjaExports = jinja$1.exports;

var jinja = jinjaExports;

const DEFAULT_SETTINGS = {
    automaticSync: true,
    syncTimeout: 60,
    downloadAudio: false,
    syncDirectory: 'voicenotes',
    deleteSynced: false,
    reallyDeleteSynced: false,
    todoTag: '',
    filenameDateFormat: 'YYYY-MM-DD',
    useDefaultFrontmatter: true,
    noteTemplate: `# {{ title }}

Date: {{ date }}

{% if summary %}
## Summary

{{ summary }}
{% endif %}

{% if points %}
## Main points

{{ points }}
{% endif %}

{% if attachments %}
## Attachments

{{ attachments }}
{% endif %}

{% if tidy %}
## Tidy Transcript

{{ tidy }}

{% else %}
## Transcript

{{ transcript }}
{% endif %}

{% if audio_link %}
[Audio]({{ audio_link }})
{% endif %}

{% if todo %}
## Todos

{{ todo }}
{% endif %}

{% if email %}
## Email

{{ email }}
{% endif %}

{% if blog %}
## Blog

{{ blog }}
{% endif %}

{% if tweet %}
## Tweet

{{ tweet }}
{% endif %}

{% if custom %}
## Others

{{ custom }}
{% endif %}

{% if tags %}
## Tags

{{ tags }}
{% endif %}

{% if related_notes %}
# Related Notes

{{ related_notes }}
{% endif %}

{% if parent_note %}
## Parent Note

- {{ parent_note }}
{% endif %}

{% if subnotes %}
## Subnotes

{{ subnotes }}
{% endif %}`,
    filenameTemplate: `
{{date}} {{title}}
`,
    excludeTags: [],
    dateFormat: 'YYYY-MM-DD',
};
class VoiceNotesPlugin extends obsidian.Plugin {
    constructor(app, manifest) {
        super(app, manifest);
        this.timeSinceSync = 0;
        this.syncIntervalId = null;
        this.ONE_SECOND = 1000;
        this.fs = app.vault.adapter;
    }
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadSettings();
            this.addSettingTab(new VoiceNotesSettingTab(this.app, this));
            if (this.settings.token) {
                this.setupAutoSync();
            }
            this.addCommand({
                id: 'manual-sync-voicenotes',
                name: 'Manual Sync Voicenotes',
                callback: () => __awaiter(this, void 0, void 0, function* () { return yield this.sync(false); }),
            });
            this.addCommand({
                id: 'insert-voicenotes-from-today',
                name: "Insert Today's Voicenotes",
                editorCallback: (editor) => __awaiter(this, void 0, void 0, function* () {
                    if (!this.settings.token) {
                        new obsidian.Notice('No access available, please login in plugin settings');
                        return;
                    }
                    const todaysRecordings = yield this.getTodaysSyncedRecordings();
                    if (todaysRecordings.length === 0) {
                        new obsidian.Notice('No recordings from today found');
                        return;
                    }
                    const listOfToday = todaysRecordings.map((filename) => `- [[${filename}]]`).join('\n');
                    editor.replaceSelection(listOfToday);
                }),
            });
            this.registerEvent(this.app.metadataCache.on('deleted', (deletedFile, prevCache) => {
                var _a, _b;
                if ((_a = prevCache.frontmatter) === null || _a === void 0 ? void 0 : _a.recording_id) {
                    this.syncedRecordingIds.remove((_b = prevCache.frontmatter) === null || _b === void 0 ? void 0 : _b.recording_id);
                }
            }));
            // Timeout to give the app time to load
            setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                this.syncedRecordingIds = yield this.getSyncedRecordingIds();
                yield this.sync(this.syncedRecordingIds.length === 0);
            }), 1000);
        });
    }
    onunload() {
        this.syncedRecordingIds = [];
        this.clearAutoSync();
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
            this.setupAutoSync();
        });
    }
    setupAutoSync() {
        this.clearAutoSync();
        if (this.settings.automaticSync) {
            this.syncIntervalId = setInterval(() => {
                this.sync(false);
            }, this.settings.syncTimeout * 60 * 1000);
        }
    }
    clearAutoSync() {
        if (this.syncIntervalId) {
            clearInterval(this.syncIntervalId);
            this.syncIntervalId = null;
        }
    }
    getRecordingIdFromFile(file) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            return (_b = (_a = this.app.metadataCache.getFileCache(file)) === null || _a === void 0 ? void 0 : _a.frontmatter) === null || _b === void 0 ? void 0 : _b['recording_id'];
        });
    }
    isRecordingFromToday(file) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            return isToday(yield ((_b = (_a = this.app.metadataCache.getFileCache(file)) === null || _a === void 0 ? void 0 : _a.frontmatter) === null || _b === void 0 ? void 0 : _b['created_at']));
        });
    }
    sanitizedTitle(title, created_at) {
        const date = formatDate(created_at, this.settings.filenameDateFormat);
        const generatedTitle = this.settings.filenameTemplate.replace('{{date}}', date).replace('{{title}}', title);
        return sanitize_1(generatedTitle);
    }
    /**
     * Return the recording IDs that we've already synced
     */
    getSyncedRecordingIds() {
        return __awaiter(this, void 0, void 0, function* () {
            const { vault } = this.app;
            const markdownFiles = vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.syncDirectory));
            return (yield Promise.all(markdownFiles.map((file) => __awaiter(this, void 0, void 0, function* () { return this.getRecordingIdFromFile(file); })))).filter((recordingId) => recordingId !== undefined);
        });
    }
    getTodaysSyncedRecordings() {
        return __awaiter(this, void 0, void 0, function* () {
            const { vault } = this.app;
            const markdownFiles = vault.getMarkdownFiles().filter((file) => file.path.startsWith(this.settings.syncDirectory));
            return (yield Promise.all(markdownFiles.map((file) => __awaiter(this, void 0, void 0, function* () { return ((yield this.isRecordingFromToday(file)) ? file.basename : undefined); })))).filter((filename) => filename !== undefined);
        });
    }
    processNote(recording_1, voiceNotesDir_1) {
        return __awaiter(this, arguments, void 0, function* (recording, voiceNotesDir, isSubnote = false, parentTitle = '', unsyncedCount) {
            try {
                if (!recording.title) {
                    new obsidian.Notice(`Unable to grab voice recording with id: ${recording.id}`);
                    return;
                }
                const title = this.sanitizedTitle(recording.title, recording.created_at);
                const recordingPath = obsidian.normalizePath(`${voiceNotesDir}/${title}.md`);
                // Process sub-notes, whether the note already exists or not
                if (recording.subnotes && recording.subnotes.length > 0) {
                    for (const subnote of recording.subnotes) {
                        yield this.processNote(subnote, voiceNotesDir, true, title, unsyncedCount);
                    }
                }
                // Check if the recording contains any excluded tags
                if (recording.tags &&
                    recording.tags.some((tag) => this.settings.excludeTags.includes(tag.name))) {
                    unsyncedCount.count++;
                    return;
                }
                // Check if the note already exists
                const noteExists = yield this.app.vault.adapter.exists(recordingPath);
                // If the note doesn't exist, or if it's a sub-note, it's treated as follows
                if (!noteExists || isSubnote) {
                    // Prepare data for the template
                    const creationTypes = ['summary', 'points', 'tidy', 'todo', 'tweet', 'blog', 'email', 'custom'];
                    const creations = Object.fromEntries(creationTypes.map((type) => [
                        type,
                        recording.creations.find((creation) => creation.type === type),
                    ]));
                    const { transcript } = recording;
                    // Destructure creations object to get individual variables if needed
                    const { summary, points, tidy, todo, tweet, blog, email, custom } = creations;
                    let audioLink = '';
                    if (this.settings.downloadAudio) {
                        const audioPath = obsidian.normalizePath(`${voiceNotesDir}/audio`);
                        if (!(yield this.app.vault.adapter.exists(audioPath))) {
                            yield this.app.vault.createFolder(audioPath);
                        }
                        const outputLocationPath = obsidian.normalizePath(`${audioPath}/${recording.recording_id}.mp3`);
                        if (!(yield this.app.vault.adapter.exists(outputLocationPath))) {
                            const signedUrl = yield this.vnApi.getSignedUrl(recording.recording_id);
                            yield this.vnApi.downloadFile(this.fs, signedUrl.url, outputLocationPath);
                        }
                        audioLink = `![[${recording.recording_id}.mp3]]`;
                    }
                    // Handle attachments
                    let attachments = '';
                    if (recording.attachments && recording.attachments.length > 0) {
                        const attachmentsPath = obsidian.normalizePath(`${voiceNotesDir}/attachments`);
                        if (!(yield this.app.vault.adapter.exists(attachmentsPath))) {
                            yield this.app.vault.createFolder(attachmentsPath);
                        }
                        attachments = (yield Promise.all(recording.attachments.map((data) => __awaiter(this, void 0, void 0, function* () {
                            if (data.type === 1) {
                                return `- ${data.description}`;
                            }
                            else if (data.type === 2) {
                                const filename = getFilenameFromUrl(data.url);
                                const attachmentPath = obsidian.normalizePath(`${attachmentsPath}/${filename}`);
                                yield this.vnApi.downloadFile(this.fs, data.url, attachmentPath);
                                return `- ![[${filename}]]`;
                            }
                        })))).join('\n');
                    }
                    // Prepare context for Jinja template
                    const formattedPoints = points ? points.content.data.map((data) => `- ${data}`).join('\n') : null;
                    const formattedTodos = todo
                        ? todo.content.data
                            .map((data) => `- [ ] ${data}${this.settings.todoTag ? ' #' + this.settings.todoTag : ''}`)
                            .join('\n')
                        : null;
                    // Format tags, replacing spaces with hyphens for multi-word tags
                    const formattedTags = recording.tags && recording.tags.length > 0
                        ? recording.tags.map((tag) => `#${tag.name.replace(/\s+/g, '-')}`).join(' ')
                        : null;
                    const context = {
                        recording_id: recording.recording_id,
                        title: title,
                        date: formatDate(recording.created_at, this.settings.dateFormat),
                        transcript: transcript,
                        audio_link: audioLink,
                        summary: summary ? summary.markdown_content : null,
                        tidy: tidy ? tidy.markdown_content : null,
                        points: formattedPoints,
                        todo: formattedTodos,
                        tweet: tweet ? tweet.markdown_content : null,
                        blog: blog ? blog.markdown_content : null,
                        email: email ? email.markdown_content : null,
                        custom: custom ? custom.markdown_content : null,
                        tags: formattedTags,
                        related_notes: recording.related_notes && recording.related_notes.length > 0
                            ? recording.related_notes
                                .map((relatedNote) => `- [[${this.sanitizedTitle(relatedNote.title, relatedNote.created_at)}]]`)
                                .join('\n')
                            : null,
                        subnotes: recording.subnotes && recording.subnotes.length > 0
                            ? recording.subnotes
                                .map((subnote) => `- [[${this.sanitizedTitle(subnote.title, subnote.created_at)}]]`)
                                .join('\n')
                            : null,
                        attachments: attachments,
                        parent_note: isSubnote ? `[[${parentTitle}]]` : null,
                    };
                    // Render the template using Jinja
                    let note = jinja.render(this.settings.noteTemplate, context).replace(/\n{3,}/g, '\n\n');
                    note = convertHtmlToMarkdown(note);
                    // Add default metadata or ensure recording_id is present
                    if (this.settings.useDefaultFrontmatter) {
                        const metadata = `---
recording_id: ${recording.recording_id}
duration: ${formatDuration(recording.duration)}
created_at: ${formatDate(recording.created_at, this.settings.dateFormat)}
updated_at: ${formatDate(recording.updated_at, this.settings.dateFormat)}
${formatTags(recording)}
---\n`;
                        note = metadata + note;
                    }
                    else {
                        const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
                        const match = note.match(frontmatterRegex);
                        if (match) {
                            // Frontmatter exists, update or add recording_id
                            const existingFrontmatter = match[1];
                            const updatedFrontmatter = existingFrontmatter.replace(/recording_id:.*\n?/, '') + `recording_id: ${recording.recording_id}\n`;
                            note = note.replace(frontmatterRegex, `---\n${updatedFrontmatter}---`);
                        }
                        else {
                            // No frontmatter, create one with recording_id
                            const metadata = `---
    recording_id: ${recording.recording_id}
---\n`;
                            note = metadata + note;
                        }
                    }
                    // Create or update note
                    if (noteExists) {
                        yield this.app.vault.modify(this.app.vault.getFileByPath(recordingPath), note);
                    }
                    else {
                        yield this.app.vault.create(recordingPath, note);
                    }
                    if (!this.syncedRecordingIds.includes(recording.recording_id)) {
                        this.syncedRecordingIds.push(recording.recording_id);
                    }
                    if (this.settings.deleteSynced && this.settings.reallyDeleteSynced) {
                        yield this.vnApi.deleteRecording(recording.recording_id);
                    }
                }
            }
            catch (error) {
                console.error(error);
                if (error.hasOwnProperty('status') !== 'undefined') {
                    this.settings.token = undefined;
                    yield this.saveSettings();
                    new obsidian.Notice(`Login token was invalid, please try logging in again.`);
                }
                else {
                    new obsidian.Notice(`Error occurred syncing some notes to this vault.`);
                }
            }
        });
    }
    sync() {
        return __awaiter(this, arguments, void 0, function* (fullSync = false) {
            try {
                console.debug(`Sync running full? ${fullSync}`);
                this.syncedRecordingIds = yield this.getSyncedRecordingIds();
                this.vnApi = new VoiceNotesApi({});
                this.vnApi.token = this.settings.token;
                const voiceNotesDir = obsidian.normalizePath(this.settings.syncDirectory);
                if (!(yield this.app.vault.adapter.exists(voiceNotesDir))) {
                    new obsidian.Notice('Creating sync directory for Voice Notes Sync plugin');
                    yield this.app.vault.createFolder(voiceNotesDir);
                }
                const recordings = yield this.vnApi.getRecordings();
                // This only happens if we aren't actually logged in, fail immediately.
                if (recordings === null) {
                    this.settings.token = undefined;
                    return;
                }
                const unsyncedCount = { count: 0 };
                if (fullSync && recordings.links.next) {
                    let nextPage = recordings.links.next;
                    do {
                        console.debug(`Performing a full sync ${nextPage}`);
                        const moreRecordings = yield this.vnApi.getRecordingsFromLink(nextPage);
                        recordings.data.push(...moreRecordings.data);
                        nextPage = moreRecordings.links.next;
                    } while (nextPage);
                }
                if (recordings) {
                    new obsidian.Notice(`Syncing latest Voicenotes`);
                    for (const recording of recordings.data) {
                        yield this.processNote(recording, voiceNotesDir, false, '', unsyncedCount);
                    }
                }
                new obsidian.Notice(`Sync complete. ${unsyncedCount.count} recordings were not synced due to excluded tags.`);
            }
            catch (error) {
                console.error(error);
                if (error.hasOwnProperty('status') !== 'undefined') {
                    this.settings.token = undefined;
                    yield this.saveSettings();
                    new obsidian.Notice(`Login token was invalid, please try logging in again.`);
                }
                else {
                    new obsidian.Notice(`Error occurred syncing some notes to this vault.`);
                }
            }
        });
    }
}

module.exports = VoiceNotesPlugin;


/* nosourcemap */